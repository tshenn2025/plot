<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mystery Coloring Book â€” Mobile Friendly</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<style>
  body {
    margin: 0;
    background: #f0f0fa;
    font-family: Arial, sans-serif;
    overflow-x: hidden;
  }
  #wrapper {
    position: relative;
    max-width: 100vw;
    max-height: 85vh;
    margin: 0 auto;
    overflow: auto;
    background: white;
    border-radius: 12px;
    box-shadow: 0 0 20px rgba(0,0,0,0.1);
  }
  canvas {
    display: block;
    max-width: 100%;
    height: auto;
    image-rendering: pixelated;
    touch-action: none; /* critical for mobile drawing */
  }
  .popup {
    background: rgba(255,255,255,0.95);
    padding: 10px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    z-index: 10;
    position: absolute;
    display: none;
  }
  #brushBtn, #eraserBtn {
    width: 60px;
    height: 60px;
    font-size: 20px;
  }
</style>
</head>
<body>

<div class="container-fluid text-center mt-3">
  <div id="wrapper" class="d-inline-block">
    <canvas id="canvas" class="border rounded"></canvas>
  </div>
</div>

<script>
// ====================== SETTINGS ======================
const IMAGE_PATH = "images.jpg";   // Your coloring page file
const BRUSH_SIZE_MIN = 1;
const BRUSH_SIZE_MAX = 20;
const BRUSH_STEP = 1;
// =====================================================

const canvas = document.getElementById('canvas');
let ctx = canvas.getContext('2d');

let brushSize = 5;
let drawing = false;
let revealed = false;
let currentColor = {r:255, g:100, b:150};
let grayColor = 128;
let isErasing = false;
let eraserSize = 8;

let baseColorCanvas, grayCanvas, maskCanvas, maskCtx;
let maskGrayCanvas, maskGrayCtx;
let logicalW, logicalH;

const img = new Image();
img.crossOrigin = "anonymous";
img.src = IMAGE_PATH + "?t=" + Date.now();

function createScaledCanvas(w, h, dpr) {
  const c = document.createElement('canvas');
  c.width = w * dpr;
  c.height = h * dpr;
  c.style.width = w + 'px';
  c.style.height = h + 'px';
  c.getContext('2d').scale(dpr, dpr);
  return c;
}

function initCanvas() {
  let zoom = Math.min(
    (window.innerWidth * 0.95) / img.width,
    (window.innerHeight * 0.85) / img.height
  );
  logicalW = img.width * zoom;
  logicalH = img.height * zoom;
  const dpr = window.devicePixelRatio || 1;

  canvas.width = logicalW * dpr;
  canvas.height = logicalH * dpr;
  canvas.style.width = logicalW + 'px';
  canvas.style.height = logicalH + 'px';

  ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);

  baseColorCanvas = createScaledCanvas(logicalW, logicalH, dpr);
  baseColorCanvas.getContext('2d').drawImage(img, 0, 0, logicalW, logicalH);

  grayCanvas = createScaledCanvas(logicalW, logicalH, dpr);
  const gctx = grayCanvas.getContext('2d');
  gctx.drawImage(img, 0, 0, logicalW, logicalH);
  const imgData = gctx.getImageData(0, 0, logicalW, logicalH);
  const data = imgData.data;
  for (let i = 0; i < data.length; i += 4) {
    const gray = data[i] * 0.299 + data[i+1] * 0.587 + data[i+2] * 0.114;
    data[i] = data[i+1] = data[i+2] = gray;
  }
  gctx.putImageData(imgData, 0, 0);

  maskCanvas = createScaledCanvas(logicalW, logicalH, dpr);
  maskCtx = maskCanvas.getContext('2d');

  maskGrayCanvas = createScaledCanvas(logicalW, logicalH, dpr);
  maskGrayCtx = maskGrayCanvas.getContext('2d');
}

img.onload = () => {
  initCanvas();
  requestAnimationFrame(draw);
};

window.addEventListener('resize', initCanvas);

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (!grayCanvas) {
    requestAnimationFrame(draw);
    return;
  }
  if (revealed) {
    ctx.drawImage(baseColorCanvas, 0, 0);
    ctx.globalCompositeOperation = "multiply";
    ctx.drawImage(maskCanvas, 0, 0);
    ctx.globalCompositeOperation = "source-over";
  } else {
    ctx.drawImage(grayCanvas, 0, 0);
    if (maskGrayCanvas) ctx.drawImage(maskGrayCanvas, 0, 0);
  }
  requestAnimationFrame(draw);
}

// Touch/mouse drawing
let activePointers = new Map();

canvas.addEventListener('pointermove', e => {
    if (!activePointers.has(e.pointerId)) return;
    activePointers.set(e.pointerId, { x: e.offsetX, y: e.offsetY });

    if (activePointers.size === 1 && drawing && !revealed) {
        e.preventDefault();
        drawBrush(e.offsetX, e.offsetY);
    }
});

canvas.addEventListener('pointerdown', e => {
    if (revealed) return;
    activePointers.set(e.pointerId, { x: e.offsetX, y: e.offsetY });

    if (activePointers.size === 1) {
        e.preventDefault();
        try { canvas.setPointerCapture(e.pointerId); } catch (err) {}
        drawing = true;
        drawBrush(e.offsetX, e.offsetY); // start immediately
    }
});


function removePointer(e) {
  activePointers.delete(e.pointerId);
  if (drawing) {
    drawing = false;
    try { canvas.releasePointerCapture(e.pointerId); } catch (err) {}
  }
}
canvas.addEventListener('pointerup', removePointer);
canvas.addEventListener('pointerleave', removePointer);
canvas.addEventListener('pointercancel', removePointer);

function drawBrush(x, y) {
  if (!maskCtx || !maskGrayCtx) return;
  if (isErasing) {
    maskCtx.save();
    maskCtx.globalCompositeOperation = 'destination-out';
    maskCtx.beginPath();
    maskCtx.arc(x, y, eraserSize, 0, Math.PI*2);
    maskCtx.fill();
    maskCtx.restore();

    maskGrayCtx.save();
    maskGrayCtx.globalCompositeOperation = 'destination-out';
    maskGrayCtx.beginPath();
    maskGrayCtx.arc(x, y, eraserSize, 0, Math.PI*2);
    maskGrayCtx.fill();
    maskGrayCtx.restore();
    return;
  }
  maskCtx.fillStyle = `rgb(${currentColor.r},${currentColor.g},${currentColor.b})`;
  maskCtx.beginPath();
  maskCtx.arc(x, y, brushSize, 0, Math.PI*2);
  maskCtx.fill();

  maskGrayCtx.fillStyle = `rgb(${grayColor},${grayColor},${grayColor})`;
  maskGrayCtx.beginPath();
  maskGrayCtx.arc(x, y, brushSize, 0, Math.PI*2);
  maskGrayCtx.fill();
}

// Keyboard shortcuts (desktop)
window.addEventListener('keydown', e => {
  if (e.key === 'e' || e.key === 'E') {
    isErasing = !isErasing;
  }
  if (e.key === '+' || e.key === '=') brushSize = Math.min(BRUSH_SIZE_MAX, brushSize + BRUSH_STEP);
  if (e.key === '-') brushSize = Math.max(BRUSH_SIZE_MIN, brushSize - BRUSH_STEP);
});
</script>
</body>
</html>


<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Mystery Coloring Book — Press SPACE to Reveal Colors!</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<style>
  /* Page layout */
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100vh;
    background: #f0f0fa;
    font-family: Arial, sans-serif;
    overflow: hidden; /* prevent accidental page scroll while drawing */
    touch-action: manipulation;
    display: flex;
    justify-content: center;
    align-items: flex-start;
  }

  /* Wrapper centers content and prevents overflow */
  #wrapper {
    position: relative;
    width: 100%;
    max-width: 100vw;
    margin: 12px auto;
    border-radius: 12px;
    box-shadow: 0 0 20px rgba(0,0,0,0.1);
    background: white;
    overflow: visible;
  }

  /* Canvas: we control its CSS size to match logical size */
  canvas {
    display: block;
    image-rendering: pixelated;
    touch-action: none; /* allow drawing without browser gestures */
    border-radius: 12px;
  }

  .popup {
    background: rgba(255,255,255,0.95);
    padding: 10px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    z-index: 10;
    position: absolute;
    display: none;
  }
</style>
</head>
<body>

<div id="wrapper">
  <canvas id="canvas"></canvas>
</div>

<script>
// ====================== SETTINGS ======================
const IMAGE_PATH = "images.jpg"; // put your image in the same folder
const BRUSH_SIZE_MIN = 1;
const BRUSH_SIZE_MAX = 10;
const BRUSH_STEP = 1;
// =====================================================

const canvas = document.getElementById('canvas');
let ctx = canvas.getContext('2d');

let brushSize = 3;
let drawing = false;
let revealed = false;
let currentColor = { r: 255, g: 100, b: 150 };
let grayColor = 128;
let isErasing = false;
let eraserSize = 3;

// Off-screen canvases
let baseColorCanvas, grayCanvas, maskCanvas, maskCtx;
let maskGrayCanvas, maskGrayCtx;
let wheelCanvas, sliderCanvas;

let logicalW = 0, logicalH = 0;

// Load image
const img = new Image();
img.crossOrigin = "anonymous";
img.src = IMAGE_PATH + "?t=" + Date.now();

// Create offscreen canvas scaled for DPR but drawing in logical coords
const createScaledCanvas = (w, h, dpr) => {
  const c = document.createElement('canvas');
  c.width = Math.round(w * dpr);
  c.height = Math.round(h * dpr);
  c.style.width = w + 'px';
  c.style.height = h + 'px';
  const cctx = c.getContext('2d');
  cctx.setTransform(dpr, 0, 0, dpr, 0, 0); // scale to logical pixels
  return c;
};

// Compute zoom that ensures full image fits viewport, leaving room for UI
function computeZoomToFit() {
  const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
  const vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);

  // Reserve some space under the canvas for the "Reveal" button and controls
  const reservedUIpx = 140; // tweak as you like
  const maxW = vw * 0.95;
  const maxH = Math.max(240, vh - reservedUIpx);

  const zx = maxW / img.width;
  const zy = maxH / img.height;
  return Math.min(zx, zy, 1); // never upscale beyond original; remove ", 1" if you want upscaling
}

function initCanvas() {
  const oldMaskCanvas = maskCanvas;
  const oldMaskGrayCanvas = maskGrayCanvas;

  const zoom = computeZoomToFit();
  logicalW = Math.round(img.width * zoom);
  logicalH = Math.round(img.height * zoom);

  const dpr = window.devicePixelRatio || 1;

  // Set canvas internal resolution and CSS size to match logical dimensions
  canvas.width = Math.round(logicalW * dpr);
  canvas.height = Math.round(logicalH * dpr);
  canvas.style.width = logicalW + 'px';
  canvas.style.height = logicalH + 'px';

  // Reset and scale ctx to logical pixels
  ctx = canvas.getContext('2d');
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  // Rebuild offscreen buffers
  baseColorCanvas = createScaledCanvas(logicalW, logicalH, dpr);
  const bctx = baseColorCanvas.getContext('2d');
  bctx.drawImage(img, 0, 0, logicalW, logicalH);

  grayCanvas = createScaledCanvas(logicalW, logicalH, dpr);
  const gctx = grayCanvas.getContext('2d');
  gctx.drawImage(img, 0, 0, logicalW, logicalH);
  const imgData = gctx.getImageData(0, 0, logicalW, logicalH);
  const data = imgData.data;
  for (let i = 0; i < data.length; i += 4) {
    const gray = data[i] * 0.299 + data[i+1] * 0.587 + data[i+2] * 0.114;
    data[i] = data[i+1] = data[i+2] = gray;
  }
  gctx.putImageData(imgData, 0, 0);

  maskCanvas = createScaledCanvas(logicalW, logicalH, dpr);
  maskCtx = maskCanvas.getContext('2d');

  maskGrayCanvas = createScaledCanvas(logicalW, logicalH, dpr);
  maskGrayCtx = maskGrayCanvas.getContext('2d');

  // Preserve previous strokes when resizing
  if (oldMaskCanvas) {
    const tmpCtx = maskCtx;
    tmpCtx.drawImage(oldMaskCanvas, 0, 0, logicalW, logicalH);
  }
  if (oldMaskGrayCanvas) {
    const tmpG = maskGrayCtx;
    tmpG.drawImage(oldMaskGrayCanvas, 0, 0, logicalW, logicalH);
  }

  // Position reveal button if exists
  const revealBtn = document.getElementById('revealBtn');
  if (revealBtn) {
    revealBtn.style.top = `${logicalH + 12}px`;
  }
}

img.onload = () => {
  initCanvas();
  createPickerUI();
  createToolButtons();
  createRevealButton(logicalH);
  updateColorPreview();
  updateModeButtons();
  requestAnimationFrame(draw);
};

window.addEventListener('resize', () => {
  initCanvas();
});

// Error display
img.onerror = () => {
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.fillStyle = "#ff5555";
  ctx.font = "20px Arial";
  ctx.fillText("Error: Could not load " + IMAGE_PATH, 20, 40);
};

// ---------- HSV → RGB ----------
function hsvToRgb(h, s, v) {
  let r, g, b;
  const i = Math.floor(h * 6);
  const f = h * 6 - i;
  const p = v * (1 - s);
  const q = v * (1 - f * s);
  const t = v * (1 - (1 - f) * s);
  switch (i % 6) {
    case 0: r = v, g = t, b = p; break;
    case 1: r = q, g = v, b = p; break;
    case 2: r = p, g = v, b = t; break;
    case 3: r = p, g = q, b = v; break;
    case 4: r = t, g = p, b = v; break;
    case 5: r = v, g = p, b = q; break;
  }
  return { r: Math.round(r*255), g: Math.round(g*255), b: Math.round(b*255) };
}

// ---------- Color picker UI ----------
function createPickerUI() {
  const wrapper = document.getElementById('wrapper');
  const size = 180;
  const radius = size / 2;

  // Wheel
  wheelCanvas = document.createElement('canvas');
  wheelCanvas.width = wheelCanvas.height = size;
  wheelCanvas.style.borderRadius = '50%';
  const wctx = wheelCanvas.getContext('2d');
  for (let px = 0; px < size; px++) {
    for (let py = 0; py < size; py++) {
      const dx = px - radius;
      const dy = py - radius;
      const distSq = dx * dx + dy * dy;
      if (distSq > radius * radius) continue;
      let hue = Math.atan2(dy, dx) / (2 * Math.PI);
      hue = (hue + 1) % 1;
      const s = Math.sqrt(distSq) / radius;
      const rgb = hsvToRgb(hue, s, 1);
      const gray = Math.round(rgb.r * 0.299 + rgb.g * 0.587 + rgb.b * 0.114);
      const g = Math.max(30, Math.min(225, gray));
      wctx.fillStyle = `rgb(${g},${g},${g})`;
      wctx.fillRect(px, py, 1, 1);
    }
  }

  // Slider
  sliderCanvas = document.createElement('canvas');
  sliderCanvas.width = 30; sliderCanvas.height = size;
  sliderCanvas.style.marginLeft = '20px';
  sliderCanvas.style.verticalAlign = 'top';
  updateSlider();

  // Palette popup
  const palettePopup = document.createElement('div');
  palettePopup.id = 'palettePopup';
  palettePopup.classList.add('popup');
  palettePopup.style.top = '60px';
  palettePopup.style.right = '10px';
  palettePopup.appendChild(wheelCanvas);
  palettePopup.appendChild(sliderCanvas);
  wrapper.appendChild(palettePopup);

  // Color preview button
  const colorPreview = document.createElement('div');
  colorPreview.id = 'colorPreview';
  colorPreview.style.position = 'absolute';
  colorPreview.style.top = '10px';
  colorPreview.style.right = '10px';
  colorPreview.style.width = '40px';
  colorPreview.style.height = '40px';
  colorPreview.style.borderRadius = '50%';
  colorPreview.style.border = '2px solid #333';
  colorPreview.style.cursor = 'pointer';
  wrapper.appendChild(colorPreview);

  // Toggle palette on preview click
  colorPreview.addEventListener('click', (e) => {
    e.stopPropagation();
    palettePopup.style.display = (palettePopup.style.display === 'none' || palettePopup.style.display === '')
      ? 'block' : 'none';
  });

  // Hide palette when clicking outside
  document.addEventListener('click', (e) => {
    if (palettePopup.style.display === 'block' && !palettePopup.contains(e.target) && e.target !== colorPreview) {
      palettePopup.style.display = 'none';
    }
  });

  // Wheel click handler (use local coords)
  wheelCanvas.addEventListener('pointerdown', (e) => {
    const rect = wheelCanvas.getBoundingClientRect();
    const px = e.clientX - rect.left;
    const py = e.clientY - rect.top;
    const dx = px - radius;
    const dy = py - radius;
    const distSq = dx * dx + dy * dy;
    if (distSq > radius * radius) return;
    let hue = Math.atan2(dy, dx) / (2 * Math.PI);
    hue = (hue + 1) % 1;
    const s = Math.sqrt(distSq) / radius;
    currentColor = hsvToRgb(hue, s, 1);
    grayColor = Math.round(currentColor.r * 0.299 + currentColor.g * 0.587 + currentColor.b * 0.114);
    updateSlider();
    updateColorPreview();
  });

  // Slider click handler
  sliderCanvas.addEventListener('pointerdown', (e) => {
    const rect = sliderCanvas.getBoundingClientRect();
    const py = e.clientY - rect.top;
    let brightness = 1 - py / size;
    brightness = Math.max(0.2, Math.min(1, brightness));
    currentColor.r = Math.round(currentColor.r * brightness);
    currentColor.g = Math.round(currentColor.g * brightness);
    currentColor.b = Math.round(currentColor.b * brightness);
    grayColor = Math.round(currentColor.r * 0.299 + currentColor.g * 0.587 + currentColor.b * 0.114);
    updateSlider();
    updateColorPreview();
  });
}

// Update brightness slider gradient
function updateSlider() {
  if (!sliderCanvas) return;
  const sctx = sliderCanvas.getContext('2d');
  const base = Math.round(currentColor.r*0.299 + currentColor.g*0.587 + currentColor.b*0.114);
  for (let py = 0; py < sliderCanvas.height; py++) {
    const brightness = Math.max(0.2, 1 - py / sliderCanvas.height);
    const g = Math.round(base * brightness);
    sctx.fillStyle = `rgb(${g},${g},${g})`;
    sctx.fillRect(0, py, 30, 1);
  }
}

function updateColorPreview() {
  const colorPreview = document.getElementById('colorPreview');
  if (colorPreview) {
    colorPreview.style.background = `rgb(${grayColor},${grayColor},${grayColor})`;
  }
}

// Create brush and eraser buttons
function createToolButtons() {
  const wrapper = document.getElementById('wrapper');
  const LONG_PRESS_TIME = 500;
  let longPressTimer;

  // Brush button
  const brushBtn = document.createElement('button');
  brushBtn.innerText = 'B';
  brushBtn.id = 'brushBtn';
  brushBtn.classList.add('btn', 'btn-primary', 'rounded-circle');
  brushBtn.style.position = 'absolute';
  brushBtn.style.top = '10px';
  brushBtn.style.left = '10px';
  brushBtn.style.width = '50px';
  brushBtn.style.height = '50px';
  wrapper.appendChild(brushBtn);

  // Eraser button
  const eraserBtn = document.createElement('button');
  eraserBtn.innerText = 'E';
  eraserBtn.id = 'eraserBtn';
  eraserBtn.classList.add('btn', 'btn-secondary', 'rounded-circle');
  eraserBtn.style.position = 'absolute';
  eraserBtn.style.top = '70px';
  eraserBtn.style.left = '10px';
  eraserBtn.style.width = '50px';
  eraserBtn.style.height = '50px';
  wrapper.appendChild(eraserBtn);

  // Brush slider popup
  const brushSliderPopup = document.createElement('div');
  brushSliderPopup.id = 'brushSliderPopup';
  brushSliderPopup.classList.add('popup');
  brushSliderPopup.style.top = '10px';
  brushSliderPopup.style.left = '70px';
  brushSliderPopup.innerHTML = `
    <label for="brushRange">Brush Size</label>
    <input id="brushRange" type="range" min="1" max="10" step="1" value="${brushSize}">
    <span id="brushVal">${brushSize}</span>px
  `;
  wrapper.appendChild(brushSliderPopup);
  const brushRange = document.getElementById('brushRange');
  const brushVal = document.getElementById('brushVal');
  brushRange.addEventListener('input', (e) => {
    brushSize = parseInt(e.target.value, 10);
    brushVal.textContent = brushSize;
  });

  // Eraser slider popup
  const eraserSliderPopup = document.createElement('div');
  eraserSliderPopup.id = 'eraserSliderPopup';
  eraserSliderPopup.classList.add('popup');
  eraserSliderPopup.style.top = '70px';
  eraserSliderPopup.style.left = '70px';
  eraserSliderPopup.innerHTML = `
    <label for="eraserRange">Eraser Size</label>
    <input id="eraserRange" type="range" min="2" max="10" step="1" value="${eraserSize}">
    <span id="eraserVal">${eraserSize}</span>px
  `;
  wrapper.appendChild(eraserSliderPopup);
  const eraserRange = document.getElementById('eraserRange');
  const eraserVal = document.getElementById('eraserVal');
  eraserRange.addEventListener('input', (e) => {
    eraserSize = parseInt(e.target.value, 10);
    eraserVal.textContent = eraserSize;
  });

  // Hide popups on click outside
  document.addEventListener('click', (e) => {
    if (brushSliderPopup.style.display === 'block' && !brushSliderPopup.contains(e.target) && e.target !== brushBtn) {
      brushSliderPopup.style.display = 'none';
    }
    if (eraserSliderPopup.style.display === 'block' && !eraserSliderPopup.contains(e.target) && e.target !== eraserBtn) {
      eraserSliderPopup.style.display = 'none';
    }
  });

  // Brush button events
  brushBtn.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    longPressTimer = setTimeout(() => {
      brushSliderPopup.style.display = 'block';
    }, LONG_PRESS_TIME);
  });
  brushBtn.addEventListener('pointerup', () => {
    clearTimeout(longPressTimer);
    isErasing = false;
    updateModeButtons();
  });

  // Eraser button events
  eraserBtn.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    longPressTimer = setTimeout(() => {
      eraserSliderPopup.style.display = 'block';
    }, LONG_PRESS_TIME);
  });
  eraserBtn.addEventListener('pointerup', () => {
    clearTimeout(longPressTimer);
    isErasing = true;
    updateModeButtons();
  });
}

function updateModeButtons() {
  const brushBtn = document.getElementById('brushBtn');
  const eraserBtn = document.getElementById('eraserBtn');
  if (brushBtn && eraserBtn) {
    if (isErasing) {
      brushBtn.classList.remove('btn-primary');
      brushBtn.classList.add('btn-secondary');
      eraserBtn.classList.remove('btn-secondary');
      eraserBtn.classList.add('btn-primary');
    } else {
      brushBtn.classList.remove('btn-secondary');
      brushBtn.classList.add('btn-primary');
      eraserBtn.classList.remove('btn-primary');
      eraserBtn.classList.add('btn-secondary');
    }
  }
  canvas.style.cursor = isErasing ? 'cell' : 'crosshair';
}

// Create reveal button
function createRevealButton(h) {
  const wrapper = document.getElementById('wrapper');
  const revealBtn = document.createElement('button');
  revealBtn.id = 'revealBtn';
  revealBtn.textContent = 'Reveal Colors';
  revealBtn.classList.add('btn', 'btn-success');
  revealBtn.style.position = 'absolute';
  revealBtn.style.top = `${h + 12}px`;
  revealBtn.style.left = '50%';
  revealBtn.style.transform = 'translateX(-50%)';
  revealBtn.disabled = false;
  revealBtn.title = "Click to reveal the full color image";
  wrapper.appendChild(revealBtn);

  revealBtn.addEventListener('click', () => {
    revealed = true;
    revealBtn.disabled = true;
    revealBtn.textContent = "Revealed";
  });
}

// ---------- Main draw loop ----------
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (!grayCanvas) {
    requestAnimationFrame(draw);
    return;
  }

  if (revealed) {
    ctx.drawImage(baseColorCanvas, 0, 0);
    ctx.globalCompositeOperation = "multiply";
    ctx.drawImage(maskCanvas, 0, 0);
    ctx.globalCompositeOperation = "source-over";
  } else {
    ctx.drawImage(grayCanvas, 0, 0);
    if (maskGrayCanvas) ctx.drawImage(maskGrayCanvas, 0, 0);
  }

  requestAnimationFrame(draw);
}

// pointer tracking for single vs multi touch
const activePointers = new Map();

// ---------- Pointer handling with correct local coordinates ----------
canvas.addEventListener('pointerdown', (e) => {
  if (revealed) return;

  // Use offsetX/offsetY so the brush is exactly under finger
  const x = e.offsetX;
  const y = e.offsetY;

  activePointers.set(e.pointerId, { x, y });

  if (activePointers.size === 1) {
    e.preventDefault();
    try { canvas.setPointerCapture(e.pointerId); } catch (err) {}
    drawing = true;
    drawBrush(x, y); // start immediately at touch point
  }
});

canvas.addEventListener('pointermove', (e) => {
  if (!activePointers.has(e.pointerId)) return;

  const x = e.offsetX;
  const y = e.offsetY;
  activePointers.set(e.pointerId, { x, y });

  if (activePointers.size === 1 && drawing && !revealed) {
    e.preventDefault();
    drawBrush(x, y);
  }
});

function removePointerAndMaybeStop(e) {
  activePointers.delete(e.pointerId);
  if (drawing) {
    drawing = false;
    try { canvas.releasePointerCapture(e.pointerId); } catch (err) {}
  }
}
canvas.addEventListener('pointerup', removePointerAndMaybeStop);
canvas.addEventListener('pointerleave', removePointerAndMaybeStop);
canvas.addEventListener('pointercancel', removePointerAndMaybeStop);

// Prevent default on iOS only for single-touch
function preventDefaultIfSingle(e) {
  if (e.touches.length === 1) {
    e.preventDefault();
  }
}
canvas.addEventListener('touchstart', preventDefaultIfSingle, { passive: false });
canvas.addEventListener('touchmove', preventDefaultIfSingle, { passive: false });
canvas.addEventListener('touchend', preventDefaultIfSingle, { passive: false });
canvas.addEventListener('touchcancel', preventDefaultIfSingle, { passive: false });

// Brush drawing (supports erase)
function drawBrush(x, y) {
  if (!maskCtx || !maskGrayCtx) return;

  if (isErasing) {
    maskCtx.save();
    maskCtx.globalCompositeOperation = 'destination-out';
    maskCtx.beginPath();
    maskCtx.arc(x, y, eraserSize, 0, Math.PI * 2);
    maskCtx.fill();
    maskCtx.restore();

    maskGrayCtx.save();
    maskGrayCtx.globalCompositeOperation = 'destination-out';
    maskGrayCtx.beginPath();
    maskGrayCtx.arc(x, y, eraserSize, 0, Math.PI * 2);
    maskGrayCtx.fill();
    maskGrayCtx.restore();

    if (!revealed) {
      ctx.save();
      ctx.globalCompositeOperation = 'destination-out';
      ctx.beginPath();
      ctx.arc(x, y, eraserSize, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
    return;
  }

  maskCtx.fillStyle = `rgb(${currentColor.r},${currentColor.g},${currentColor.b})`;
  maskCtx.beginPath();
  maskCtx.arc(x, y, brushSize, 0, Math.PI * 2);
  maskCtx.fill();

  maskGrayCtx.fillStyle = `rgb(${grayColor},${grayColor},${grayColor})`;
  maskGrayCtx.beginPath();
  maskGrayCtx.arc(x, y, brushSize, 0, Math.PI * 2);
  maskGrayCtx.fill();

  if (!revealed) {
    ctx.fillStyle = `rgb(${grayColor},${grayColor},${grayColor})`;
    ctx.beginPath();
    ctx.arc(x, y, brushSize, 0, Math.PI * 2);
    ctx.fill();
  }
}

// Keyboard shortcuts
window.addEventListener('keydown', (e) => {
  if (e.key === 'e' || e.key === 'E') {
    isErasing = !isErasing;
    updateModeButtons();
  }
  if (e.key === '+' || e.key === '=') {
    brushSize = Math.min(BRUSH_SIZE_MAX, brushSize + BRUSH_STEP);
  }
  if (e.key === '-') {
    brushSize = Math.max(BRUSH_SIZE_MIN, brushSize - BRUSH_STEP);
  }
  if (e.key === ' ') {
    revealed = !revealed;
    const revealBtn = document.getElementById('revealBtn');
    if (revealBtn) {
      revealBtn.disabled = revealed;
      revealBtn.textContent = revealed ? "Revealed" : "Reveal Colors";
    }
  }
});

// Right-click → save image
canvas.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  canvas.toBlob((blob) => {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'my-mystery-coloring.png';
    a.click();
  });
});
</script>
</body>
</html>
